

\documentclass[english]{article} % \documentclass[a4paper]{article}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc} % \usepackage[utf8]{inputenc}
\usepackage{geometry}
% \geometry{verbose,tmargin=2cm,bmargin=2cm,lmargin=3cm,rmargin=3cm}
\usepackage{amsthm, amsmath,amssymb} % ,amsfonts
\usepackage{setspace}
\usepackage{esint}
\usepackage[authoryear]{natbib}
\onehalfspacing

\makeatletter
\usepackage{authblk}
\usepackage[multiple]{footmisc}
\usepackage{pdflscape}
\usepackage{booktabs}

% \usepackage{jheppub}
%%\usepackage[round]{natbib}
\usepackage[colorlinks=true,urlcolor=blue]{hyperref}
\usepackage{graphicx}
\usepackage{pdflscape}
\usepackage{color}
\usepackage{float}

\definecolor{blue}{rgb}{.2,.2,.7}
\definecolor{red}{rgb}{.7,.2,.2}
\definecolor{green}{rgb}{0,.6,.3}
\definecolor{gray}{rgb}{0.45,0.45,0.45}
\newcommand{\btext}[1]{\textcolor{blue}{#1}}
\newcommand{\rtext}[1]{\textcolor{red}{#1}}
\newcommand{\gtext}[1]{\textcolor{green}{#1}}
\newcommand{\wtext}[1]{\textcolor{white}{#1}}
\newcommand{\old}[1]{\textcolor{gray}{#1}}
\definecolor{gray90}{RGB}{229,229,229}
\definecolor{gray77}{RGB}{196,196,196}
\definecolor{gray60}{RGB}{153,153,153}

\renewcommand{\thefootnote}{\alph{footnote}}
%%\newcommand{\acronym}[1]{\textsc{#1}}
%%\newcommand{\class}[1]{\mbox{\textsf{#1}}}
\newcommand{\code}[1]{\mbox{\texttt{#1}}}
\newcommand{\pkg}[1]{{\normalfont\fontseries{b}\selectfont #1}}
\newcommand{\proglang}[1]{\textsf{#1}}

\newcommand\XOR{\mathbin{\char`\^}}
\newcommand\independent{\protect\mathpalette{\protect\independenT}{\perp}}
\def\independenT#1#2{\mathrel{\rlap{$#1#2$}\mkern2mu{#1#2}}}

\theoremstyle{plain}
\newtheorem*{thm*}{\protect\theoremname}
\theoremstyle{plain}
\newtheorem*{lem*}{\protect\lemmaname}

\makeatother
\usepackage{babel}
\providecommand{\lemmaname}{Lemma}
\providecommand{\theoremname}{Theorem}


%\VignetteEngine{knitr::knitr}
%\VignetteIndexEntry{Introduction}
<<include=FALSE, results='hide'>>=
  library("ggplot2")
  library("gridExtra")
  library("tikzDevice")

  require("knitr")
  require("simcausal")

  options(simcausal.verbose = FALSE)
  cache_opt <- TRUE
  opts_chunk$set(fig.path='TablesFigs/knitR-',fig.align='center',fig.show='hold',size='footnotesize')
  knit_hooks$set(pdfcrop = hook_pdfcrop)
  options(width=100)  # make the printing fit on the page
  set.seed(1121)   # make the results repeatable
@

\begin{document}
\SweaveOpts{concordance=TRUE}

<<eval=TRUE, include=FALSE, results='hide', message=FALSE>>=
# --------------------------------------------------------------------------------------------
# Specificy the observed data distribution with a DAG object
# --------------------------------------------------------------------------------------------
create_OnetDAG <- function(K = 5, nC = 1, network = "prefattach", trimKmax = NULL) {
  `%+%` <- function(a, b) paste0(a, b)
  require("igraph")
  require("simcausal")
  options(simcausal.verbose=FALSE)
  if (nC>1) print("generating DAG with nC: " %+% nC)

  # --------------------------------------------------------------------------------------------
  # preferential attachment (BA) model (power law deg distribution):
  # --------------------------------------------------------------------------------------------
  generate.igraph.prefattach <- function(n, power, zero.appeal, m, trimKmax, ...) {
    g <- sample_pa(n, power = power, zero.appeal = zero.appeal, m = m)
    g <- as.directed(as.undirected(g, mode = "collapse"), mode = "mutual")
    sparse_AdjMat <- simcausal::igraph.to.sparseAdjMat(g)
    if (!missing(trimKmax)) {
      # print("trimKmax: "); print(trimKmax)
      NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat, trimKmax = trimKmax)
    } else {
      NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat)
    }
    return(NetInd_out$NetInd_k)
  }
  # --------------------------------------------------------------------------------------------
  # small world (Watts-Strogatz network) model:
  # --------------------------------------------------------------------------------------------
  generate.igraph.smallwld <- function(n, dim, nei, p, ...) {
    # if (!is.null(seed)) set.seed(seed)
    g <- sample_smallworld(dim = 1, size = n, nei = nei, p = p, loops = FALSE, multiple = FALSE)
    g <- as.directed(g, mode = c("mutual"))
    sparse_AdjMat <- simcausal::igraph.to.sparseAdjMat(g) # From igraph object to sparse adj. matrix:
    NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat) # From igraph object to simcausal/tmlenet input (NetInd_k, nF, Kmax):
    # if (!is.null(seed)) set.seed(NULL)
    return(NetInd_out$NetInd_k)
  }
  # --------------------------------------------------------------------------------------------
  # Network sampler(s) from igraph (regular graph model)
  # Generate regular random graphs with same degree for each node
  # K - degree of each node
  # --------------------------------------------------------------------------------------------
  generate.regular <- function(n, K, ...) {
    if (n <= 200) K <- 5
    igraph.reg <- igraph::sample_k_regular(no.of.nodes = n, k = K, directed = TRUE, multiple = FALSE)
    sparse_AdjMat <- simcausal::igraph.to.sparseAdjMat(igraph.reg)
    NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat)
    return(NetInd_out$NetInd_k)
  }
  # --------------------------------------------------------------------------------------------
  # sample a network of nC independent communities, same network within each community, total sample size is n
  # --------------------------------------------------------------------------------------------
  gen_network_k_reg_indClusters <- function(n, nC = 1, K, ...) {
    if (n <= 200) {
      K <- 5; nC <- 1
    }
    igraph.reg <- igraph::sample_k_regular(no.of.nodes = as.integer(n/nC), k = K, directed = TRUE, multiple = FALSE)
    sparse_AdjMat <- simcausal::igraph.to.sparseAdjMat(igraph.reg)
    NetInd_out <- simcausal::sparseAdjMat.to.NetInd(sparse_AdjMat)
    NetInd_mat_fixed <- NetInd_out$NetInd_k
    NetInd_mat_list <- lapply(seq(nC), function(k_comm) NetInd_mat_fixed + (k_comm - 1)*as.integer(n/nC))
    NetInd_mat <- do.call('rbind', NetInd_mat_list)
    return(NetInd_mat)
  }
  # --------------------------------------------------------------------------------------------
  # Defining the DAG object
  # --------------------------------------------------------------------------------------------
  D <- DAG.empty()
  if (network %in% "prefattach") {
    print("simulating pref attach.")
    # NETWORK MODEL USED IN SCENARIO Rdata_gym_noboot_depW_allScen:
    if (!is.null(trimKmax)) {
      D <- D + network("Net.prefattach", netfun = "generate.igraph.prefattach", power = 0.5, zero.appeal = 5, m = 5, trimKmax = trimKmax)
    } else {
      D <- D + network("Net.prefattach", netfun = "generate.igraph.prefattach", power = 0.5, zero.appeal = 5, m = 5)
    }
  } else if (network %in% "smallworld") {
    print("simulating small world")
    D <- D + network("Net", netfun = "generate.igraph.smallwld", dim = 1, nei = 9, p = 0.1) # small world
  } else if (network %in% "regular") {
    print("simulating regular network graph")
    D <- D + network("Net", netfun = "generate.regular", K = K) # regular (lattice) graph
  } else {
    stop("network undefined")
  }
  D <- D +
      node("latWcat", distr = "rcat.b0", probs = c(0.0494, 0.1823, 0.2806, 0.2680,0.1651, 0.0546)) +
      node("latWnorm", distr = "rnorm", mean = 0, sd = 1) +
      node("HUB", distr = "rconst", const = ifelse(nF >= 25, 1, 0)) # is this person a hub?
  D <- D +
      node("W1", distr = "rcat.b1", probs = c(0.0494, 0.1823, 0.2806, 0.2680,0.1651, 0.0546)) +
      node("W2", distr = "rbern", prob = plogis(-0.2)) +
      node("WNoise", distr = "rbern", prob = plogis(-0.4))

  D <- D +
      node("PA", distr = "rbern", prob = W2*0.05 + (1-W2)*0.15) + # Physically active at baseline (depends on W2)
      node("nF.PA", distr = "rconst", const = sum(PA[[1:Kmax]]), replaceNAw0 = TRUE) # number of phys. active friends
  # Define exposure 0/1 as completely random:
  D <- D + node("A", distr = "rbern", prob = 0.25)
  # Defining the network summary measures based on A:
  D <- D + node("sum.net.A", distr = "rconst", const = (sum(A[[1:Kmax]])*(HUB==0) + sum((W1[[1:Kmax]] > 4)*A[[1:Kmax]])*(HUB==1)), replaceNAw0 = TRUE)

  D <- D +
      node("probY", distr = "rconst",
          const = plogis(ifelse(PA == 1,
                  +5 - 15*(nF.PA < 1), # the probability of maintaining gym membership drops if no friends are PA
                  -8.0 + 0.25*A) +
                  +0.5*sum.net.A + 0.25*nF.PA*sum.net.A + 0.5*nF.PA +
                  +0.5*(W1-1) - 0.58*W2 +
                  -0.5*(3.477-1) + 0.58*0.4496 +
                  +0.5*latWnorm + 0.5*sum(latWnorm[[1:Kmax]])),
          replaceNAw0 = TRUE)
  D <- D + node("Y", distr = "rbern", prob = probY)
  D <- set.DAG(D, latent.v = c("latWcat", "latWnorm", "probY"), n.test = 200)
}
@

% ------------------------------------------------------------
% \section{Node degree distributions}
% ------------------------------------------------------------

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
datO_1K <- sim(create_OnetDAG(network = "prefattach"), n = 1000)
datO_10K <- sim(create_OnetDAG(network = "prefattach"), n = 10000)
Net_mat_1K <- attributes(datO_1K)$netind_cl$NetInd
nF_1K <- attributes(datO_1K)$netind_cl$nF
Net_mat_10K <- attributes(datO_10K)$netind_cl$NetInd
nF_10K <- attributes(datO_10K)$netind_cl$nF
@

<<eval=TRUE, echo=FALSE, pdfcrop=TRUE, message=FALSE, fig.width=5, fig.height=3.5, fig.cap = "Node degree distribution for the preferential attachment network with 1,000 (bottom plot) and 10,000 (top plot) observations.">>=
par(mgp = c(1.7, 1, 0))
plot(table(nF_10K)/nrow(datO_10K), xlab = "Number of friends", ylab = "Total proportion")
par(mgp = c(1.7, 1, 0))
plot(table(nF_1K)/nrow(datO_1K), xlab = "Number of friends", ylab = "Total proportion")
@


<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
datO_1K <- sim(create_OnetDAG(network = "smallworld"), n = 1000)
datO_10K <- sim(create_OnetDAG(network = "smallworld"), n = 10000)
Net_mat_1K <- attributes(datO_1K)$netind_cl$NetInd
nF_1K <- attributes(datO_1K)$netind_cl$nF
Net_mat_10K <- attributes(datO_10K)$netind_cl$NetInd
nF_10K <- attributes(datO_10K)$netind_cl$nF
@

<<eval=TRUE, echo=FALSE, pdfcrop=TRUE, message=FALSE, fig.width=5, fig.height=3.5, fig.cap = "Node degree distribution for the small world network with 1,000 (bottom plot) and 10,000 (top plot) observations.">>=
par(mgp = c(1.7, 1, 0))
plot(table(nF_10K)/nrow(datO_10K), xlab = "Number of friends", ylab = "Total proportion")
par(mgp = c(1.7, 1, 0))
plot(table(nF_1K)/nrow(datO_1K), xlab = "Number of friends", ylab = "Total proportion")
@

% ------------------------------------------------------------
% \newpage{}
% \section{Simulation results}
% ------------------------------------------------------------

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
`%+%` <- function(a, b) paste0(a, b)
# setwd("/Users/olegsofrygin/GoogleDrive/Network_TMLE/Betsy_sims")
# outdir <- "./Rdata_gym_boot/"
source("helper_plotting.R")
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
cbbPalette <- c(
  "#b20019",
  "#0072b2",
  "#b29900",
  "#F0E442",
  "#009E73",
  "#0072B2",
  "#CC79A7"
  )

get_legend<-function(myggplot){
  tmp <- ggplot_gtable(ggplot_build(myggplot))
  leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
  legend <- tmp$grobs[[leg]]
  return(legend)
}

# plot the mean CI length or coverage (later will be pasted together into two panels)
plot.CIs.gg <- function(data.df, only_1net = TRUE, cov = FALSE, bw = FALSE){
  require(ggplot2)
  if (!cov) {
    p <- ggplot(data.df, aes(x = scen.labs, y = tmle.est, ymin=CIlow, ymax=CIhi))
    if(only_1net) {
      p <- p + geom_point(aes(color = CI.type, shape = CI.type), position = position_dodge(0.35), size = 0.9)
      # p <- p + geom_linerange(aes(color = CI.type, linetype = CI.type), alpha = 1, size = 0.6, position = position_dodge(0.35))
      p <- p + geom_errorbar(aes(color = CI.type, linetype = CI.type), alpha = 1, width = 0.3, position = position_dodge(0.35))
    } else {
      p <- p + geom_point(aes(color = CI.type, shape = CI.type), position = position_dodge(0.35), size = 0.9)
      # p <- p + geom_linerange(aes(color = CI.type, linetype = CI.type, type = network), size = 0.6, alpha = 1, position = position_dodge(0.35))
      p <- p + geom_errorbar(aes(color = CI.type, linetype = CI.type, type = network), alpha = 1, width = 0.3, position = position_dodge(0.35))
    }

    p <- p + scale_colour_manual(values= cbbPalette)

    p <- p + theme_bw() + coord_flip()
    p <- p + geom_hline(aes(yintercept=0), lty=2)
    p <- p + facet_grid(N ~ ., labeller = label_both) + xlab('Scenario')
    # p <- p + facet_grid(. ~ N, labeller = label_both) + xlab('Scenario')
    p <- p + ylab('Mean estimate \\& 95\\% CI length')
    p <- p + theme(axis.title.y = element_blank(),
                   axis.title.x = element_text(size = 8),
                   plot.margin = unit(c(1, 0, 1, 1), "lines"),
                   legend.position="top")

    if (bw) {
      p <- p + scale_colour_brewer()
      p <- p + scale_color_grey()
      p <- p + scale_fill_grey()
    }

  } else {
    p <- ggplot(data.df, aes(x = scen.labs, y = CIcover))
    if(only_1net) {
      p <- p + geom_point(aes(color = CI.type, shape = CI.type), position = position_dodge(0.35), size = 0.8)
    } else {
      p <- p + geom_point(aes(color = CI.type, shape = CI.type, type = network), position = position_dodge(0.35), size = 0.8)
    }

    p <- p + scale_colour_manual(values= cbbPalette)

    p <- p + theme_bw() + coord_flip()
    p <- p + geom_hline(aes(yintercept=0.95), lty=2)
    p <- p + facet_grid(N ~ ., labeller = label_both) + xlab('Scenario')
    # p <- p + facet_grid(. ~ N, labeller = label_both) + xlab('Scenario')
    p <- p + ylab('Coverage')
    p <- p + theme(axis.title.y = element_blank(),
                   axis.title.x = element_text(size = 8),
                   plot.margin = unit(c(1, 1, 1, 0), "lines"),
                   axis.text.y  = element_blank(),
                   legend.position = "none"
                   # axis.ticks.y = element_blank()
                   )

    if (bw) {
      p <- p + scale_colour_brewer()
      p <- p + scale_color_grey()
      p <- p + scale_fill_grey()
    }
  }
  return(p)
}
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# obtain the data in long format from the results for one type of the CI only
get_1CItype <- function(CI.type, simRes_all = simRes_all, network = c("prefattach","smallworld"), Qscen_idx = 1) {
  scen.names <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "scen.name")))
  network.types <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "network")))
  nsamp <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "nsamp")))
  ATE <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "ATE")))

  sel_idx <- network.types %in% network

  simRes_all_sel <- simRes_all[sel_idx]
  network.types_sel <- network.types[sel_idx]
  ATE <- ATE[sel_idx]

  sims_MeanRes_byscen <- lapply(simRes_all_sel, '[[', "sims_MeanRes_byscen")
  sims_MeanRes_byscen_Q <- lapply(sims_MeanRes_byscen, '[[', Qscen_idx)

  tmle.est <- unlist(lapply(sims_MeanRes_byscen_Q,
                        function(scen_table) scen_table["tmle","est"]))

  CI.get <- CI.type %+% "CI" %+% "len"
  CIlow <- unlist(lapply(sims_MeanRes_byscen_Q,
                        function(scen_table) scen_table["tmle","est"] - scen_table["tmle",CI.get]/2))
  CIhi <- unlist(lapply(sims_MeanRes_byscen_Q,
                        function(scen_table) scen_table["tmle","est"] + scen_table["tmle",CI.get]/2))

  # print("CI.get: "); print(CI.get); print(CIlow)
  # CI.get <- CI.type %+% "CI" %+% "cover"

  CI.get <- CI.type %+% "CI" %+% "cov"
  CIcover <- unlist(lapply(sims_MeanRes_byscen_Q,
                        function(scen_table) scen_table["tmle", CI.get]))

  data_sim_stats <- data.frame(row.names=NULL,
                              scen.names=scen.names[sel_idx],
                              network = network.types_sel,
                              ATE = ATE,
                              N = nsamp[sel_idx],
                              tmle.est, CI.type, CIlow, CIhi, CIcover)

  return(data_sim_stats)
}
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# ----------------------------------------------------------------------------------------------------
# new network runs (iid W, bootstrap = 500, nsims = 1000):
# pref. attachment & small-world networks
# ----------------------------------------------------------------------------------------------------
# print(getwd())
# load(file="../" %+% outdir%+%"simRes_all.RData")
# names(simRes_all)
# load("/Users/olegsofrygin/GoogleDrive/Network_TMLE/Betsy_sims/Rdata_gym_boot/simRes_all.RData")
load("./source_sim_data/simRes_all.RData")


data_sim_stats_1net_PA <- rbind(get_1CItype("condW.",  simRes_all, network = "prefattach", Qscen_idx = 1),
                             # get_1CItype("boot", simRes_all, network = "prefattach", Qscen_idx = 1),
                             get_1CItype("condW.indepQ.",  simRes_all, network = "prefattach", Qscen_idx = 1))
data_sim_stats_1net_SW <- rbind(get_1CItype("condW.",  simRes_all, network = "smallworld", Qscen_idx = 1),
                             # get_1CItype("boot", simRes_all, network = "smallworld", Qscen_idx = 1),
                             get_1CItype("condW.indepQ.",  simRes_all, network = "smallworld", Qscen_idx = 1))
@


<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# ----------------------------------------------------------------------------------------------------
# Define labels and prep data for plotting (pref attachment network):
# ----------------------------------------------------------------------------------------------------
(scen.names <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "scen.name"))))
(network.types <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "network"))))
(nsamp <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "nsamp"))))
(ATE <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "ATE"))))
(sims_MeanRes_tabs <- lapply(simRes_all, '[[', "sims_MeanRes_byscen"))
CI_types_new <- c(
  "dependent IC Var",
  "iid Var")
# CI_types_new <- c(
#   CI_types[1] %+% " Var ($\\sigma_{IC,N}^{2}$)",
#   CI_types[2] %+% " Var ($\\sigma_{boot,N}^{2}$)",
#   CI_types[3] %+% " Var ($\\sigma_{IID,N}^{2}$)"
# )
scenario_labelsEYgstar <- c(
  "$g^*_1$ (random 35\\%)", # $$1/n \sum{E_{g_1^*}Y_i}
  "$g^*_2$ (dynamic intervention)",
  "$g^*_3$ (network intervention)",
  "$g^*_2$ + $g^*_3$")
scenario_labelsATE <- c(
  "Contrast: $g^*_1$ vs. random 10\\%",
  "Contrast: $g^*_2$ vs. random 10\\%",
  "Contrast: $g^*_3$ vs. observed $g$",
  "Contrast: ($g^*_2$ + $g^*_3$) vs. random 10\\%")

make_final_dataset <- function(data_sim_stats_1net) {
  scen.names <- data_sim_stats_1net$scen.names
  CI_types <- unique(data_sim_stats_1net$CI.type)
  scenario_names <- unique(scen.names)
  # "EY.f.g1.stoch0.4"  "ATE.f.g1.stoch0.4"
  # "EY.f.g1.dynamic"   "ATE.f.g1.dynamic"
  # "EY.f.g1.nFPA"      "ATE.f.g1.nFPA"
  # "EY.f.g1.A_nFPA"    "ATE.f.g1.A_nFPA"
  data_sim_stats_1net$CI.type <- factor(rep(CI_types_new, each = length(scenario_names)*length(unique(nsamp))), levels = CI_types_new)
  (length(scenario_labelsEYgstar)+length(scenario_labelsATE))*length(unique(nsamp))*length(unique(data_sim_stats_1net$CI.type))
  nrow(data_sim_stats_1net)
  # order by all mean EY_gstar parameters first then all ATE parameters
  data_sim_stats_1net <- data_sim_stats_1net[order(data_sim_stats_1net$ATE), ]
  data_sim_stats_1net$scen.labs <- factor(
                                          c(rep(rep(scenario_labelsEYgstar, each = length(unique(nsamp))), length(unique(data_sim_stats_1net$CI.type))),
                                            rep(rep(scenario_labelsATE, each = length(unique(nsamp))), length(unique(data_sim_stats_1net$CI.type)))),
                                          # levels = c(scenario_labels[4], scenario_labels[3], scenario_labels[2], scenario_labels[1]))
                                          # levels = c(scenario_labels[6], scenario_labels[4], scenario_labels[2],
                                          #           scenario_labels[5], scenario_labels[3], scenario_labels[1]))
                                          levels = c(scenario_labelsATE[4], scenario_labelsEYgstar[4],
                                                     scenario_labelsATE[3], scenario_labelsEYgstar[3],
                                                     scenario_labelsATE[2], scenario_labelsEYgstar[2],
                                                     scenario_labelsATE[1], scenario_labelsEYgstar[1]))
  levels(data_sim_stats_1net$scen.labs)
  return(data_sim_stats_1net)
}
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# ----------------------------------------------------------------------------------------------------------------
# select only a subset of one scenario (all, EYg or ATE/contrast):
# by_ATE_scen <- "all"
# by_ATE_scen <- "ATE"
# by_ATE_scen <- "EY.gstar"
# ----------------------------------------------------------------------------------------------------------------
plot_CIs_by_scen <- function(by_ATE_scen, data_sim_res_1net, bw = FALSE) {
  if (by_ATE_scen %in% "all") {
    data <- data_sim_res_1net
  } else if (by_ATE_scen %in% "EY.gstar") {
    data <- data_sim_res_1net[!data_sim_res_1net$ATE,]
    data$scen.labs <- factor(data$scen.labs, levels = rev(scenario_labelsEYgstar))
  } else if (by_ATE_scen %in% "ATE") {
    data <- data_sim_res_1net[data_sim_res_1net$ATE,]
    data$scen.labs <- factor(data$scen.labs, levels = rev(scenario_labelsATE))
  }
  plotCIlen <- plot.CIs.gg(data, cov = FALSE, bw = bw)
  plotCIcov <- plot.CIs.gg(data, cov = TRUE, bw = bw)
  legend.save <- get_legend(plotCIlen)
  plotCIlen <- plotCIlen + theme(legend.position = "none")
  plotCIs <- grid.arrange(legend.save, plotCIlen, plotCIcov,
                nrow = 2, ncol = 2,
                layout_matrix = rbind(c(1,1), c(2,3)),
                widths = c(0.60,0.40),
                heights = c(0.15, 2.9))
  grid.arrange(legend.save, plotCIlen, plotCIcov,
                nrow = 2, ncol = 2,
                layout_matrix = rbind(c(1,1), c(2,3)),
                widths = c(0.67,0.33),
                heights = c(0.15, 2.9))
}
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# --------------------------------------------------------------------------------------------
# Plot re-scaled histogram densities vs. their theoretical standard normal limit
# --------------------------------------------------------------------------------------------
make_ggplot_hist <- function(model_scen, simRes_byscen, scen.name, estimator = "tmle") {
  require("ggplot2")
  Normal_density_fin <- NULL
  nsamp <- simRes_byscen[["Sim_params"]][["nsamp"]]
  # print("nsamp"); print(nsamp)
  K <- simRes_byscen[["Sim_params"]][["K"]]
  psi0 <- simRes_byscen[["psi0"]]
  # mean stats over sims:
  sims_MeanRes_byscen <- simRes_byscen[["sims_MeanRes_byscen"]]
  # raw results for all sims:
  sims_RawRes_byscen <- simRes_byscen[["sims_RawRes_byscen"]]
  # scen1_Raw_ests <- sims_RawRes_byscen[["Qh.corr"]][["est"]]
  # scen2_Raw_ests <- sims_RawRes_byscen[["Q.miss"]][["est"]]
  # scen3_Raw_ests <- sims_RawRes_byscen[["h.miss"]][["est"]]
  # print(sims_MeanRes_byscen[[model_scen]])
  # sigma2_0 <- sims_MeanRes_byscen[[model_scen]][,"empVar"]
  sigma2_0 <- sims_MeanRes_byscen[[model_scen]][,"TrueVar"]
  # sigma2_N <- sims_MeanRes_byscen[[model_scen]][,"depVar.Est"]
  all_psi_n <- sims_RawRes_byscen[[model_scen]][["est"]]
  est_names <- colnames(all_psi_n)
  all_psi_n_scaled <- (all_psi_n - psi0)
  # all_psi_n_scaled <- sqrt(nsamp/K) * (all_psi_n - psi0)
  for (est_name in est_names) {
    # print("rescaling est_name"); print(est_name)
    # print("sigma2_0"); print(sigma2_0[est_name])
    all_psi_n_scaled[, est_name] <- all_psi_n_scaled[, est_name] / sqrt(sigma2_0[est_name])
    # The theoretical limiting distribution
    vu <- seq(min(all_psi_n_scaled[, est_name])-0.1, max(all_psi_n_scaled[, est_name])+0.1, by = .001)
    Normal_density  <- data.frame(x=vu, y=dnorm(x = vu, mean = 0, sd = 1))
    Normal_density$estimator <- est_name
    Normal_density$N <- nsamp
    Normal_density$scen.name <- scen.name
    Normal_density_fin <- rbind(Normal_density_fin, Normal_density)
  }
  all_psi_n_scaled <- data.frame(all_psi_n_scaled)
  all_psi_n_scaled_melted <- reshape2::melt(all_psi_n_scaled)
  all_psi_n_scaled_melted$N <- nsamp
  all_psi_n_scaled_melted$scen.name <- scen.name
  colnames(all_psi_n_scaled_melted) <- c("estimator", "estimand", "N", "scen.name")
  # print(nrow(all_psi_n_scaled_melted))
  all_psi_n_scaled_melted <- all_psi_n_scaled_melted[all_psi_n_scaled_melted[,"estimator"] %in% estimator,]
  # print(head(all_psi_n_scaled_melted))
  # print(nrow(all_psi_n_scaled_melted))
  Normal_density_fin <- Normal_density_fin[Normal_density_fin$estimator %in% estimator,]
  # print(head(Normal_density_fin))
  # print(estimator)
  # print(unique(all_psi_n_scaled_melted$estimator))
  # print(unique(Normal_density_fin$estimator))
  return(list(all_psi_n_scaled_melted = all_psi_n_scaled_melted, Normal_density = Normal_density_fin))
}
@

<<eval=TRUE, echo=FALSE, message=FALSE, results='hide'>>=
# ----------------------------------------------------------------------------------------------------
# Use saved raw simulation results to generate new plots
# ----------------------------------------------------------------------------------------------------
use_sims_plot_byK <- function(network = "prefattach", estimator = "h.iptw", est.plot = "IPTW", scenATE = FALSE) {
  # What network type?
  # network <- "prefattach"
  # network <- "smallworld"
  # Which estimator to use for histgrams?
  # estimator <- "h.iptw"; est.plot <- "IPTW"
  # estimator <- "tmle"; est.plot <- "TMLE"
  # ATE or EYg?
  # scenATE <- FALSE
  # scenATE <- TRUE
  (sim_names <- names(simRes_all))
  (K_vec <- unique(unlist(lapply(simRes_all, function(sim) sim[['Sim_params']][['K']]))))
  (scen.names <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "scen.name"))))
  (network.types <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "network"))))
  (nsamp <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "nsamp"))))
  N_select <- nsamp   # N_select <- c(1000, 1000, 10000)
  (ATE <- as.vector(unlist(lapply(lapply(simRes_all, '[[', "Sim_params"), '[[', "ATE"))))
  (networks <- unique(unlist(lapply(simRes_all, function(sim) sim[['Sim_params']][["network"]]))))
  (model_names <- names(simRes_all[[1]][["sims_MeanRes_byscen"]]))
  # (scenarios <- unique(unlist(lapply(simRes_all, function(sim) sim[['Sim_params']][["scen.name"]]))))
  (scenarios <- unique(unlist(lapply(simRes_all, function(sim) sim[['Sim_params']][["scen.name"]]))[network.types %in% network]))

  scenarios_select_EY <- c(scenarios[1],scenarios[3],scenarios[5], scenarios[7])
  scenarios_select_ATE <- c(scenarios[2],scenarios[4],scenarios[6], scenarios[8])
  scenario_labels <- c(
    "g[1]^symbol('*')", # "g[1]'*'", #  (random 25\\%)
    "Contrast: g[1]^symbol('*')", #  vs. 10\\%
    "g[2]^symbol('*')", # (dynamic intervention)
    "Contrast: g[2]^symbol('*')", #  vs. 10\\%
    "g[3]^symbol('*')", #  (network intervention)
    "Contrast: g[3]^symbol('*')", #  vs. 10\\%
    "g[2]^symbol('*') + g[3]^symbol('*')",
    "Contrast: (g[2]^symbol('*') + g[3]^symbol('*'))" #  vs. 10\\%
    )
  scenario_labels <- factor(scenario_labels, levels = scenario_labels)
  # levels(scenario_labels)
  if (!scenATE) {
    scenarios_sel <- scenarios_select_EY
    scen.type.name <- "EY"
  } else {
    scenarios_sel <- scenarios_select_ATE
    scen.type.name <- "ATE"
  }
  # loop over all scenarios (put all N in one plot for the same scenario):
  ggplothist_byscen <- NULL
  all_psi_n_scaled_scens <- NULL
  Norm_density_scens <- NULL
  for (scenario in scenarios_sel) {
    # print("network: " %+% network)
    # print("scenario: " %+% scenario)
    scen_select <- scen.names %in% scenario
    net_select <- network.types %in% network
    nsamp_select <- nsamp %in% N_select
    idx_select <- which(scen_select & net_select & nsamp_select)
    # print("plotting results for scenarios: " %+% names(simRes_all[idx_select]))
    # ggplothist_byscen <- c(ggplothist_byscen,
    ggplothist_byscen <- lapply(idx_select, function(idx)
                                make_ggplot_hist(model_scen = model_names[1],
                                                 simRes_byscen = simRes_all[[idx]],
                                                 scen.name = scenario,
                                                 estimator = estimator))

    all_psi_n_scaled_melted <- lapply(ggplothist_byscen, '[[', "all_psi_n_scaled_melted")
    all_psi_n_scaled_melted <- do.call("rbind", all_psi_n_scaled_melted)
    # hist(ggplothist_byscen[[1]]$all_psi_n_scaled_melted$estimand)
    # hist(all_psi_n_scaled_melted[,"estimand"])
    # nrow(all_psi_n_scaled_melted)
    # browser()
    all_psi_n_scaled_melted$scen <- scenario_labels[which(scenarios %in% scenario)]
    all_psi_n_scaled_melted$scenario <- scenario
    Normal_density <- lapply(ggplothist_byscen, '[[', "Normal_density")
    Normal_density <- do.call("rbind", Normal_density)
    Normal_density$scen <- scenario_labels[which(scenarios %in% scenario)]
    Normal_density$scenario <- scenario
    all_psi_n_scaled_scens <- rbind(all_psi_n_scaled_scens, all_psi_n_scaled_melted)
    Norm_density_scens <- rbind(Norm_density_scens, Normal_density)
  }
  # unique(all_psi_n_scaled_scens$scenario)
  # nrow(all_psi_n_scaled_scens)
  # unique(Norm_density_scens$scenario)
  # is.factor(all_psi_n_scaled_scens$scen); levels(all_psi_n_scaled_scens$scen)
  # is.factor(Norm_density_scens$scen); levels(Norm_density_scens$scen)
  # unique(all_psi_n_scaled_scens$N)
  # unique(Norm_density_scens$N)
  # summary(all_psi_n_scaled_scens[all_psi_n_scaled_scens$N %in% 1000,])
  # range(Norm_density_scens[Norm_density_scens$N %in% 1000,]$x)
  # plot(arrangeGrob(grobs=ggplothist_byscen, nrow = 1, ncol = length(N_select)))
  # hist_by_est <- ggplot(data.frame(all_psi_n_scaled_melted), aes(x=estimand)) +
  hist_by_est <- ggplot(data.frame(all_psi_n_scaled_scens), aes(x=estimand)) +
                  geom_histogram(aes(y=..density..), binwidth=0.10, colour="black", fill="white") +
                  # geom_line(data=Normal_density, aes(x=x, y=y), colour = "red") +
                  geom_line(data=Norm_density_scens, aes(x=x, y=y), colour = "red") +
                  theme_bw() +
                  # facet_grid(estimator ~ .) +
                  # facet_grid(. ~ estimator) +
                  # facet_grid(. ~ N, labeller = label_both) +
                  # facet_grid(scen ~ N, labeller = label_both) +
                  facet_grid(scen ~ N, labeller = label_parsed, scales = "free_x") +
                  # ggtitle(est.plot %+% " histograms (black) vs. asymptotic limiting distributions (red)") +
                  # ggtitle("rescaled $(\\psi_n-\\psi_0)$ vs. N(0,1), scenario: " %+% simRes_byscen[["simname"]] %+% ", " %+% model_scen) +
                  theme(
                        plot.title = element_text(lineheight=1),
                        axis.title.y = element_blank(),
                        axis.title = element_text(lineheight=.9, size = 7),
                        panel.spacing = grid::unit(0.1, "lines"), # panel.margin = grid::unit(0.1, "lines"),
                        plot.margin = grid::unit(c(0,0.4,+0.5,+0.4),"lines")
                        )
                  #        +
                  # xlab('Transformed estimates (centered at the true parameter value and rescaled by the true S.D.)')
  return(hist_by_est)
}
@

% ------------------------------------------------------------------------------------------------------------
\section{Main results}
% ------------------------------------------------------------------------------------------------------------
<<"CIres.EY.prefattach", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the preferential attachment network, by sample size, interevention and CI type. Results shown for average expected outcomes only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_PA; network <- "prefattach"
plot_CIs_by_scen(by_ATE_scen="EY.gstar", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_PA), bw = FALSE)
@

<<"CIres.EY.prefattach.bw", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the preferential attachment network, by sample size, interevention and CI type. Results shown for average expected outcomes only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_PA; network <- "prefattach"
plot_CIs_by_scen(by_ATE_scen="EY.gstar", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_PA), bw = TRUE)
@

<<"CIres.EY.smwld", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the small world network, by sample size, interevention and CI type. Results shown for average expected outcomes only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_SW; network <- "smallworld"
plot_CIs_by_scen(by_ATE_scen="EY.gstar", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_SW), bw = FALSE)
@

<<"CIres.EY.smwld.bw", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the small world network, by sample size, interevention and CI type. Results shown for average expected outcomes only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_SW; network <- "smallworld"
plot_CIs_by_scen(by_ATE_scen="EY.gstar", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_SW), bw = TRUE)
@

<<"hist.TMLE.EY.prefattach", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=100, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed TMLE (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for average expected outcomes in the preferential attachment network.">>=
use_sims_plot_byK(network = "prefattach", estimator = "tmle", est.plot = "TMLE", scenATE = FALSE)
@

<<"hist.TMLE.EY.smwld", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=100, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed TMLE (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for average expected outcomes in the small world network.">>=
use_sims_plot_byK(network = "smallworld", estimator = "tmle", est.plot = "TMLE", scenATE = FALSE)
@

% ------------------------------------------------------------------------------------------------------------
\newpage
\section{Supplementary results}
% ------------------------------------------------------------------------------------------------------------
<<"CIres.ALL.prefattach", eval=TRUE, fig.keep='last', fig.width=7, fig.height=8, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the preferential attachment network, by sample size, interevention and CI type. Results shown for all scenarios.">>=
# data_sim_stats_1net <- data_sim_stats_1net_PA; network <- "prefattach"
plot_CIs_by_scen(by_ATE_scen="all", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_PA))
@

<<"CIres.ALL.smwld", eval=TRUE, fig.keep='last', fig.width=7, fig.height=8, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the small world network, by sample size, interevention and CI type. Results shown for all scenarios.">>=
# data_sim_stats_1net <- ;
# network <- "smallworld"
plot_CIs_by_scen(by_ATE_scen="all", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_SW))
@

<<"CIres.ATE.prefattach", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the preferential attachment network, by sample size, interevention and CI type. Results shown for contrasts only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_PA; network <- "prefattach"
plot_CIs_by_scen(by_ATE_scen="ATE", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_PA))
@

<<"CIres.ATE.smwld", eval=TRUE, fig.keep='last', fig.width=7, fig.height=5, dev='tikz', pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Mean 95\\% CI length (left panel) and coverage (right panel) for the small world network, by sample size, interevention and CI type. Results shown for contrasts only.">>=
# data_sim_stats_1net <- data_sim_stats_1net_SW; network <- "smallworld"
plot_CIs_by_scen(by_ATE_scen="ATE", data_sim_res_1net = make_final_dataset(data_sim_stats_1net_SW))
@

% ------------------------------------------------------------------------------------------------------------
% TMLE RESULTS (ATE)
% ------------------------------------------------------------------------------------------------------------
<<"hist.TMLE.ATE.prefattach", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed TMLE (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for contrasts in preferential attachment network.">>=
use_sims_plot_byK(network = "prefattach", estimator = "tmle", est.plot = "TMLE", scenATE = TRUE)
@
<<"hist.TMLE.ATE.smwld", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed TMLE (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for contrasts in small world network.">>=
use_sims_plot_byK(network = "smallworld", estimator = "tmle", est.plot = "TMLE", scenATE = TRUE)
@

% ------------------------------------------------------------------------------------------------------------
% IPTW RESULTS (EY and ATE)
% ------------------------------------------------------------------------------------------------------------
<<"hist.IPTW.EY.prefattach", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed IPTW (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for average expected outcomes in the preferential attachment network.">>=
use_sims_plot_byK(network = "prefattach", estimator = "h.iptw", est.plot = "IPTW", scenATE = FALSE)
@

<<"hist.IPTW.ATE.prefattach", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed IPTW (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for contrasts in the preferential attachment network.">>=
use_sims_plot_byK(network = "prefattach", estimator = "h.iptw", est.plot = "IPTW", scenATE = TRUE)
@

<<"hist.IPTW.EY.smwld", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed IPTW (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for average expected outcomes in the small world network.">>=
use_sims_plot_byK(network = "smallworld", estimator = "h.iptw", est.plot = "IPTW", scenATE = FALSE)
@

<<"hist.IPTW.ATE.smwld", eval=TRUE, fig.keep='last', fig.width=8, fig.height=8, dev='png', dpi=72, pdfcrop=TRUE, echo=FALSE, message=FALSE, fig.cap = "Distribution of the transformed IPTW (black) compared to the theoretical limiting distribution (red) by sample size (x-axis) and intervention type (y-axis). The estimates were centered at the truth and re-scaled by true SD. Results shown are for contrasts in the small world network.">>=
use_sims_plot_byK(network = "smallworld", estimator = "h.iptw", est.plot = "IPTW", scenATE = TRUE)
@

\end{document}

